#!/usr/bin/ruby

#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
#
#Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
#Square	 	P4,n=n**2	 	1, 4, 9, 16, 25, ...
#Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
#Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
#Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
#Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
#The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
#This is the only set of 4-digit numbers with this property.
#Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

# did not notice that the order can be discontinuous in agonal way...
# in the very beginning i wasted a lot of time on eliminating redundant numbers.
# finally i realize that recursive way should be fast enough... after 2 days...
# i should refactor it later!! recursive way should be very compact

def tri(n)
  n*(n+1)/2
end

def square(n)
  n**2
end

def pent(n)
  n*(3*n-1)/2
end

def hex(n)
  n*(2*n-1)
end

def hept(n)
  n*(5*n-3)/2
end

def oct(n)
  n*(3*n-2)
end

oct_array=[]
tri_p=[]
def angle(name)
  result = []
  tail = []
  (1..200).each do |c|
  if send(name,c) > 999 && send(name,c) < 10000 && (send(name,c)%100).to_s.length == 2
    result << send(name,c)
    tail << send(name,c)%100
  end
  end
  [result,tail.uniq]
end
a=angle(:tri)
b=angle(:square)
c=angle(:pent)
d=angle(:hex)
e=angle(:hept)
f=angle(:oct)
p f[0].length,f[1].length
def reduce(g,all)
new_g = []
all.uniq.each do |n|
  new_g += g[0].select {|v| v.to_s =~ /\d{2}#{n}/}
end
new_g_tail = (new_g.collect {|x|x%100}).uniq
[new_g,new_g_tail]
end
#f=reduce(f,b[1]+c[1]+d[1]+e[1]+a[1])
#e=reduce(e,b[1]+c[1]+d[1]+f[1]+a[1])
#d=reduce(d,b[1]+c[1]+f[1]+e[1]+a[1])
#c=reduce(c,b[1]+f[1]+d[1]+e[1]+a[1])
#b=reduce(b,f[1]+c[1]+d[1]+e[1]+a[1])
#a=reduce(a,b[1]+c[1]+d[1]+e[1]+f[1])
@begin_number = 0
def recursive(all,one)
  if all.length == 1
    test = (all[0][0].select {|bbb| bbb.to_s =~ /#{one[1].first}\d{2}/})
    if test.length > 0
    #p "begin with #{@begin_number}"
    #p "end with #{test.inspect}"
       if @begin_number.to_s =~ /#{test.first%100}\d{2}/
	 p "begin with #{@begin_number}"
	 p "#{@second_number},#{@third_number},#{@fourth_number},#{one[0].first}"
         p "================success end one loop in #{test.first}"
	 p "the sum is #{@begin_number + @second_number + @third_number + @fourth_number + one[0].first + test.first}"
       end
    else
      #p "================failed one loop to get a #{one[1].first}xx number in #{all[0][0].inspect}"
    end
  else
    one[0].each do |nn|
      case all.length
      when 5
	@begin_number = nn
      when 4
	@second_number = nn
      when 3
	@third_number = nn
      when 2
	@fourth_number = nn
      end
        #p "--------------------------------------------"
        #p "begin with #{nn}"
      mm = nn%100
      all.each do |aa|
	tmp = aa[0].select {|vv| vv.to_s =~ /#{mm}\d{2}/}
	tail = tmp.collect {|vv| vv%100 }
	if tmp.length == 0
	  #p "===fail in #{aa[0].inspect} to get a #{mm} number, try next aa"
	  next
	end
	#p "we get #{tmp.inspect}"
	recursive(all-[aa],[tmp,tail])
      end
    end
  end
end
recursive([b,c,d,e,f],a)
exit
#after_f=[]
#f[1].each do |ff|
#  after_f += (a[0].select {|v| v.to_s =~ /#{ff}\d{2}/})+(b[0].select {|v| v.to_s =~ /#{ff}\d{2}/})+(c[0].select {|v| v.to_s =~ /#{ff}\d{2}/})+(d[0].select {|v| v.to_s =~ /#{ff}\d{2}/})+(e[0].select {|v| v.to_s =~ /#{ff}\d{2}/})
#end
#p after_f
#[a[0],b[0],c[0],d[0],e[0]].each do |gg|
#  p gg&after_f.uniq
#end
#def find_angle(a,b)
#  p a,b
#tail=b[1].select {|v| v == a[0][0].to_s[0,2].to_i }
#number=b[0].select {|v| v.to_s =~ /\d{2}#{tail}/}
#[number,tail]
#end
exit
